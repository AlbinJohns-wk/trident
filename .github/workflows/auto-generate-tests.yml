name: Auto-Generate Unit Tests

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '**.go'
      - '!**_test.go'
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  generate-tests:
    name: Generate Unit Tests for Changed Code
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'pull_request') ||
      (github.event_name == 'issue_comment' && 
       github.event.issue.pull_request && 
       contains(github.event.comment.body, '/approve-tests'))
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref || github.event.issue.pull_request.head.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Get base branch
        id: base
        run: |
          if [ "${{ github.event_name }}" = "issue_comment" ]; then
            # Fetch PR details for comment trigger
            PR_NUM=${{ github.event.issue.number }}
            BASE_REF=$(gh pr view $PR_NUM --json baseRefName -q .baseRefName)
            echo "ref=$BASE_REF" >> $GITHUB_OUTPUT
          else
            echo "ref=${{ github.event.pull_request.base.ref }}" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect changed Go files
        id: changes
        run: |
          # Get changed .go files (exclude test files)
          git fetch origin ${{ steps.base.outputs.ref }}
          CHANGED_FILES=$(git diff --name-only origin/${{ steps.base.outputs.ref }}...HEAD | grep '\.go$' | grep -v '_test\.go$' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No Go files changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Define exclude patterns from Makefile
          EXCLUDE_PATTERNS=(
            "client/clientset"
            "client/informers"
            "client/listers"
            "storage/external_test"
            "astrads/api/v1alpha1"
            "ontap/api/azgo"
            "ontap/api/rest"
            "fake"
            "mocks/"
            "operator/controllers/provisioner"
            "storage_drivers/astrads/api/v1beta1"
          )
          
          # Filter out excluded packages
          FILTERED_FILES=""
          for file in $CHANGED_FILES; do
            EXCLUDE=false
            for pattern in "${EXCLUDE_PATTERNS[@]}"; do
              if [[ "$file" == *"$pattern"* ]]; then
                EXCLUDE=true
                break
              fi
            done
            
            if [ "$EXCLUDE" = false ]; then
              FILTERED_FILES="$FILTERED_FILES$file"$'\n'
            fi
          done
          
          if [ -z "$FILTERED_FILES" ]; then
            echo "No files after filtering exclusions"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Extract unique package paths
          PACKAGES=""
          for file in $FILTERED_FILES; do
            if [ -n "$file" ]; then
              # Get directory of the file
              dir=$(dirname "$file")
              # Convert to Go package path
              pkg="github.com/netapp/trident/$dir"
              PACKAGES="$PACKAGES$pkg"$'\n'
            fi
          done
          
          UNIQUE_PACKAGES=$(echo "$PACKAGES" | sort -u | grep -v '^$')
          
          echo "Affected packages:"
          echo "$UNIQUE_PACKAGES"
          
          # Save to files for later steps
          echo "$FILTERED_FILES" > /tmp/changed_files.txt
          echo "$UNIQUE_PACKAGES" > /tmp/affected_packages.txt
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "file_count=$(echo "$FILTERED_FILES" | grep -c . || echo 0)" >> $GITHUB_OUTPUT

      - name: Extract functions from git diff
        if: steps.changes.outputs.has_changes == 'true'
        id: extract
        run: |
          # Get the diff and extract new/modified function signatures
          git fetch origin ${{ steps.base.outputs.ref }}
          DIFF_OUTPUT=$(git diff origin/${{ steps.base.outputs.ref }}...HEAD)
          
          # Extract function names from diff (lines starting with +func)
          # This captures: +func FunctionName(...) or +func (receiver) FunctionName(...)
          FUNCTIONS=$(echo "$DIFF_OUTPUT" | grep -E '^\+func [A-Z]' | sed 's/^+func //' | awk '{print $1}' | sed 's/[(){].*$//' | sort -u)
          
          if [ -z "$FUNCTIONS" ]; then
            echo "No new/modified exported functions found in diff"
            echo "[]" > /tmp/functions.json
            echo "function_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Found functions in diff:"
          echo "$FUNCTIONS"
          
          # Build JSON array with function info
          FUNCTION_JSON='['
          FIRST=true
          
          while IFS= read -r file; do
            if [ -n "$file" ] && [ -f "$file" ]; then
              # Get package name
              PKG=$(head -20 "$file" | grep "^package " | awk '{print $2}')
              
              # Extract each function's code from the file
              for func_name in $FUNCTIONS; do
                # Check if this function exists in this file
                if grep -q "^func.*$func_name" "$file" 2>/dev/null; then
                  # Extract the function code (simple approach - get function and next 50 lines)
                  FUNC_CODE=$(awk "/^func.*$func_name/,/^}/" "$file" | head -100)
                  
                  if [ -n "$FUNC_CODE" ]; then
                    # Escape for JSON
                    FUNC_CODE_ESCAPED=$(echo "$FUNC_CODE" | jq -Rs .)
                    
                    if [ "$FIRST" = true ]; then
                      FIRST=false
                    else
                      FUNCTION_JSON+=","
                    fi
                    
                    FUNCTION_JSON+="{\"name\":\"$func_name\",\"file\":\"$file\",\"package\":\"$PKG\",\"code\":$FUNC_CODE_ESCAPED}"
                  fi
                fi
              done
            fi
          done < /tmp/changed_files.txt
          
          FUNCTION_JSON+=']'
          
          echo "$FUNCTION_JSON" > /tmp/functions.json
          FUNC_COUNT=$(echo "$FUNCTION_JSON" | jq 'length')
          echo "Function count: $FUNC_COUNT"
          echo "function_count=$FUNC_COUNT" >> $GITHUB_OUTPUT

      - name: Generate unit tests using AI
        if: steps.extract.outputs.function_count != '0'
        id: generate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Create simplified test generation script
          cat > /tmp/generate_tests.py << 'SCRIPT'
          import json
          import os
          import sys
          import requests
          from pathlib import Path
          
          def call_github_copilot(prompt, model="gpt-4o"):
              """Call GitHub Copilot API via Azure OpenAI endpoint"""
              token = os.environ.get("GITHUB_TOKEN")
              headers = {
                  "Authorization": f"Bearer {token}",
                  "Content-Type": "application/json"
              }
              
              payload = {
                  "messages": [
                      {"role": "system", "content": "You are an expert Go test engineer. Generate comprehensive unit tests using Go's testing package and table-driven test patterns. Return ONLY the test code without explanations or markdown formatting."},
                      {"role": "user", "content": prompt}
                  ],
                  "model": model,
                  "temperature": 0.3,
                  "max_tokens": 2000
              }
              
              try:
                  response = requests.post(
                      "https://models.inference.ai.azure.com/chat/completions",
                      headers=headers,
                      json=payload,
                      timeout=60
                  )
                  
                  if response.status_code == 200:
                      return response.json()["choices"][0]["message"]["content"]
                  else:
                      print(f"GitHub API failed: {response.status_code} - {response.text}", file=sys.stderr)
                      return None
              except Exception as e:
                  print(f"GitHub API error: {e}", file=sys.stderr)
                  return None
          
          def call_openai(prompt, model="gpt-4o-mini"):
              """Fallback to OpenAI API"""
              api_key = os.environ.get("OPENAI_API_KEY")
              if not api_key:
                  return None
                  
              headers = {
                  "Authorization": f"Bearer {api_key}",
                  "Content-Type": "application/json"
              }
              
              payload = {
                  "model": model,
                  "messages": [
                      {"role": "system", "content": "You are an expert Go test engineer. Generate comprehensive unit tests using Go's testing package and table-driven test patterns. Return ONLY the test code without explanations or markdown formatting."},
                      {"role": "user", "content": prompt}
                  ],
                  "temperature": 0.3,
                  "max_tokens": 2000
              }
              
              try:
                  response = requests.post(
                      "https://api.openai.com/v1/chat/completions",
                      headers=headers,
                      json=payload,
                      timeout=60
                  )
                  
                  if response.status_code == 200:
                      return response.json()["choices"][0]["message"]["content"]
                  else:
                      print(f"OpenAI API failed: {response.status_code}", file=sys.stderr)
                      return None
              except Exception as e:
                  print(f"OpenAI API error: {e}", file=sys.stderr)
                  return None
          
          def extract_code_block(text):
              """Extract Go code from markdown code blocks"""
              text = text.strip()
              if "```go" in text:
                  parts = text.split("```go")
                  if len(parts) > 1:
                      code = parts[1].split("```")[0]
                      return code.strip()
              elif "```" in text:
                  parts = text.split("```")
                  if len(parts) > 2:
                      return parts[1].strip()
              return text
          
          def generate_test_for_function(func_info):
              """Generate test for a single function"""
              prompt = f"""Generate a comprehensive unit test for this Go function.

Package: {func_info['package']}
Function: {func_info['name']}

Function code:
```go
{func_info['code']}
```

Requirements:
1. Use table-driven test pattern where appropriate
2. Test multiple scenarios including edge cases
3. Test error conditions if function returns errors
4. Use standard testing package
5. Function name should be Test{func_info['name']}
6. Return ONLY the test function code, no package or import statements

Generate the test code:"""
              
              print(f"Generating test for {func_info['name']}...", file=sys.stderr)
              
              # Try GitHub Copilot first
              result = call_github_copilot(prompt)
              if result:
                  return result
              
              # Fallback to OpenAI
              print(f"Falling back to OpenAI for {func_info['name']}...", file=sys.stderr)
              result = call_openai(prompt)
              return result
          
          def main():
              # Load functions
              with open("/tmp/functions.json", "r") as f:
                  functions = json.load(f)
              
              if not functions:
                  print("No functions to process", file=sys.stderr)
                  return
              
              generated_tests = {}
              
              for func_info in functions:
                  func_name = func_info.get("name", "")
                  if not func_name:
                      continue
                  
                  # Generate test
                  test_code = generate_test_for_function(func_info)
                  if not test_code:
                      print(f"Failed to generate test for {func_name}", file=sys.stderr)
                      continue
                  
                  # Clean up code
                  test_code = extract_code_block(test_code)
                  
                  # Organize by test file
                  test_file = func_info["file"].replace(".go", "_test.go")
                  if test_file not in generated_tests:
                      generated_tests[test_file] = {
                          "package": func_info["package"],
                          "tests": []
                      }
                  
                  generated_tests[test_file]["tests"].append({
                      "function": func_name,
                      "code": test_code
                  })
              
              # Save generated tests
              with open("/tmp/generated_tests.json", "w") as f:
                  json.dump(generated_tests, f, indent=2)
              
              print(f"Generated tests for {len(generated_tests)} files", file=sys.stderr)
          
          if __name__ == "__main__":
              main()
          SCRIPT
          
          # Install Python dependencies
          pip install -q requests
          
          # Generate tests
          python3 /tmp/generate_tests.py
          
          if [ -f /tmp/generated_tests.json ]; then
            TEST_COUNT=$(cat /tmp/generated_tests.json | jq 'length')
            if [ "$TEST_COUNT" -gt 0 ]; then
              echo "success=true" >> $GITHUB_OUTPUT
            else
              echo "success=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Write generated tests to files
        if: steps.generate.outputs.success == 'true'
        run: |
          # Create script to write test files
          python3 << 'SCRIPT'
          import json
          import os
          from pathlib import Path
          
          with open("/tmp/generated_tests.json", "r") as f:
              tests = json.load(f)
          
          for test_file, content in tests.items():
              # Check if file already exists
              file_exists = os.path.exists(test_file)
              
              if file_exists:
                  # Append to existing file
                  with open(test_file, "a") as f:
                      f.write("\n\n// Auto-generated tests\n")
                      for test in content["tests"]:
                          f.write(f"\n{test['code']}\n")
              else:
                  # Create new file
                  Path(test_file).parent.mkdir(parents=True, exist_ok=True)
                  with open(test_file, "w") as f:
                      f.write(f"package {content['package']}\n\n")
                      f.write("import (\n")
                      f.write('\t"testing"\n')
                      f.write(")\n\n")
                      f.write("// Auto-generated tests\n")
                      for test in content["tests"]:
                          f.write(f"\n{test['code']}\n")
              
              print(f"{'Updated' if file_exists else 'Created'}: {test_file}")
          SCRIPT

      - name: Run tests on affected packages
        if: steps.generate.outputs.success == 'true'
        id: coverage
        continue-on-error: true
        run: |
          # Read affected packages
          PACKAGES=$(cat /tmp/affected_packages.txt | tr '\n' ' ')
          
          echo "Running tests on affected packages:"
          echo "$PACKAGES"
          
          # Run tests with coverage
          go test -v -short -coverprofile=coverage_pr.out $PACKAGES || true
          
          # Calculate coverage per package
          if [ -f coverage_pr.out ]; then
            echo "## Coverage Report" > /tmp/coverage_report.md
            echo "" >> /tmp/coverage_report.md
            echo "| Package | Coverage |" >> /tmp/coverage_report.md
            echo "|---------|----------|" >> /tmp/coverage_report.md
            
            go tool cover -func=coverage_pr.out | grep -v "total:" | while read line; do
              # Extract package and coverage
              pkg=$(echo "$line" | awk '{print $1}' | sed 's|github.com/netapp/trident/||' | cut -d'/' -f1-2 | sort -u)
              if [ -n "$pkg" ]; then
                echo "Processing: $pkg"
              fi
            done
            
            # Get overall coverage
            OVERALL=$(go tool cover -func=coverage_pr.out | grep "total:" | awk '{print $3}')
            echo "" >> /tmp/coverage_report.md
            echo "**Overall coverage for changed packages:** $OVERALL" >> /tmp/coverage_report.md
            
            echo "coverage=$OVERALL" >> $GITHUB_OUTPUT
          else
            echo "No coverage data generated" >> /tmp/coverage_report.md
            echo "coverage=N/A" >> $GITHUB_OUTPUT
          fi

      - name: Create PR comment with results
        if: steps.generate.outputs.success == 'true' && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read generated tests
            const testsData = JSON.parse(fs.readFileSync('/tmp/generated_tests.json', 'utf8'));
            const testFiles = Object.keys(testsData);
            
            // Read coverage report
            let coverageReport = 'Coverage data not available';
            if (fs.existsSync('/tmp/coverage_report.md')) {
              coverageReport = fs.readFileSync('/tmp/coverage_report.md', 'utf8');
            }
            
            // Build comment
            let comment = '## ü§ñ Auto-Generated Unit Tests\n\n';
            comment += '### üìù Generated Test Files:\n';
            
            for (const file of testFiles) {
              const testCount = testsData[file].tests.length;
              comment += `- \`${file}\` (${testCount} test${testCount > 1 ? 's' : ''})\n`;
            }
            
            comment += '\n### üìä Coverage Report:\n\n';
            comment += coverageReport;
            
            comment += '\n\n### üìã Generated Tests Preview:\n\n';
            
            // Show preview of first test file
            const firstFile = testFiles[0];
            if (firstFile) {
              comment += '<details>\n';
              comment += `<summary>${firstFile}</summary>\n\n`;
              comment += '```go\n';
              const preview = testsData[firstFile].tests.slice(0, 2).map(t => t.code).join('\n\n');
              comment += preview.substring(0, 2000); // Limit size
              if (preview.length > 2000) comment += '\n// ... truncated ...';
              comment += '\n```\n';
              comment += '</details>\n\n';
            }
            
            comment += '---\n';
            comment += '‚úÖ **To approve and commit these tests:** Comment `/approve-tests` below\n';
            comment += '‚ùå **To reject:** No action needed, tests will not be committed\n\n';
            comment += '*Note: Tests have been generated but not committed. Please review before approval.*';
            
            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: Commit generated tests
        if: |
          steps.generate.outputs.success == 'true' && 
          github.event_name == 'issue_comment' && 
          contains(github.event.comment.body, '/approve-tests')
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add all test files
          git add '*_test.go'
          
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git commit -m "chore: add auto-generated unit tests [skip ci]

          Generated by Auto-Generate Unit Tests workflow
          Approved by: @${{ github.event.comment.user.login }}"
          
          git push

      - name: Acknowledge approval
        if: |
          steps.generate.outputs.success == 'true' && 
          github.event_name == 'issue_comment' && 
          contains(github.event.comment.body, '/approve-tests')
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '‚úÖ Tests approved and committed to the PR branch!'
            });
